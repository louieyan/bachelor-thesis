---
title: "theis 3.3.2"
author: "Yanlei"
date: "2019年4月3日"
output: html_document 
---
这个文件是论文3.3.2节的代码


贝叶斯方法计算窗宽
```{r}
compute_bayes_h <- function(x, sample_data, alp = 0.5, bet = 15) {
  # Return a number h_x which is computd by bayesian method using bino ker
  # Input: 
  #           x: the point where it's corresponding h need to be computed
  # sample_data: data sample
  #    alp, bet: piror distribution beta's alpha params
  n <- length(sample_data)
  numer <- numeric(n)
  denom <- numeric(n)
  i <- 1
  for (i in 1:n) {
    X_i <- sample_data[i]
    if (X_i <= x+1) {
      k <- 0:X_i
      numer[i] = sum((x^k * beta(X_i+alp-k+1, x+bet+1-X_i)) / (factorial(x+1-X_i) * factorial(k) * factorial(X_i-k)))
      denom[i] = sum((x^k * beta(X_i+alp-k, x+bet+1-X_i)) / (factorial(x+1-X_i) * factorial(k) * factorial(X_i-k)))
    } else {
      numer[i] <- 0
      denom[i] <- 0
    }
    i <- i + 1
  }
  sum(numer) / sum(denom)
}

```


计算$\hat{f}(x)$

```{r}

make_f_hat_discrete <- function(ker, sample_data) {
  # Apply bayesian bandwidths in associated discrete estimation
  # Input: 
  #      `     h`: bandwiths, same length as vector 0:max(sample_data)
  #         `ker`: kernel function, actually is bino kernel
  # `sample_data`: the data sample from which the estimate is to be computed
  # Output:
  #       a estimated pmf
  
  n <- length(sample_data)
  f_hat_discrete <- function(x) {
    h_x <- compute_bayes_h(x, sample_data)
    sum(ker(x, h_x, sample_data)) / n
  }
  f_hat_discrete
}
```


下面是产生样本的函数

```{r eval=FALSE, include=FALSE}
generate_samples <- function(distribution, n, N, ...) {
  # Return a n-by-N matrix which each col is sampled from given distribution
  # Input:
  #  distribution: a random generation function(e.g. rpios)
  #             n: number of each sample
  #             N: number of samples
  #           ...: other params of distribution
  sample_data <- matrix(nrow = n, ncol = N)
  for (i in seq_along(1:N)) {
    sample_data[, i] <- distribution(n, ...)
  }
  sample_data
}
```

```{r eval=FALSE, include=FALSE}
# A test
samples <- generate_samples(rpois, 1000, 50, 3)
```


```{r eval=FALSE, include=FALSE}
compute_fs_hat <- function(samples, ker, bayesian, h_fun = hcvd.fun,
                           type = "data") {
  # Returns fs_hat (a list of funcs or vectors)
  # If retruns a list of vectors, odd index indicates suport set x
  # even index indicates corresponding estimated pmf/pdf
  # Input:
  #   samples: samples data generated by generate_samples
  #       ker: kernel function. can be a func name or a string
  # bayesian: bool value, whether use bayesian bandwidth selection
  #   h_fun: function to compute h, the bandwidth
  #   type: return value is a list of funcs or a list of vectors

  N_sim <- ncol(samples)
  fs_hat <- list()
  if (type == "func") {
    for (t in seq_along(1:N_sim)) {
      sample_data <- samples[, t]
      if (bayesian) {
        # for bayesian local bandwidth selection
        f_hat <- make_f_hat_discrete(ker, sample_data) # ker is bino
      } else { # for continuous CV and plug-in and ROT
         h <- h_fun(sample_data) # all three mothods should have only one
                                 #params --- sample data
         f_hat <- make_f_hat(h, ker, sample_data)
      }
      fs_hat <- c(fs_hat, f_hat)
    }
    
  } else {
    # for discrete CV, only hcvd.fun is called
    for (t in seq_along(1:N_sim)) {
      sample_data <- samples[, t]
      h <- h_fun(sample_data, NULL, ker)$hcv # ker should be a string
      est <- kpmfe.fun(sample_data, h, "discrete", ker)
      f_hat <- est$est.fn 
      x <- est$eval.points
      
      fs_hat <- c(fs_hat, data.frame(x, f_hat))
    }
    
  }
  fs_hat
}
# some examples
compute_fs_hat(demo_samples, "bino", FALSE) # discrete CV
compute_fs_hat(demo_samples, bino, TRUE, type = "func") # discrete bayes
demo_samples2 <- rnorm(10, 5, 5)
compute_fs_hat(demo_samples2, gauss, FALSE, dpik, type = "func")#continuous
```


下面是计算估计的$\widehat{\text{MISE}}$的函数

```{r eval=FALSE, include=FALSE}
library(purrr)
compute_MISE <- function(f, fs_hat, samples, N_sim, ...) {
  # Return MISE of f_hat
  # Input: 
  #      f: true pdf/pmf
  #      x: support of f and f_hat
  #  N_sim: number of simulation 
  #    ...: other params for `f`
  # fs_hat: 
  #        1. a list of functions (estimated pdfs/pmfs)
  #        2. a list of vectors
  ISE <- numeric(N_sim)
  
  if (typeof(fs_hat[[1]]) == "closure") { # fs_hat is a list of funcs
    #f_x <- f(x, ...) # to avoid computing inside for loop
    for (t in seq_along(1:N_sim)) {
      # f_hat is not vectorized, so use map() from purrr
      x <- min(samples[, t]):max(samples[, t])
      f_x <- f(x, ...)
      ISE[t] <- sum((map_dbl(x, fs_hat[[t]]) - f_x)^2)
    }
  } else {
    for (t in seq_along(1:N_sim)) {
      f_x <- f(fs_hat[[2*t-1]], ...)
      ISE[t] <- sum((fs_hat[[2*t]] - f_x)^2, na.rm = TRUE)
    }
  }
  mean(ISE, na.rm = TRUE)
}
```

计算MISE，bayesian方法
```{r eval=FALSE, include=FALSE}
n_s <- c(25, 50, 100, 200, 400, 800)
MISEs_1 <- numeric(length(n_s))
i <- 1
set.seed(2333)
for (n in n_s) {
  samples <- generate_samples(rpois, n, 50, 8)
  fs_hat <- compute_fs_hat(samples, bino, TRUE, type = "func")
  MISEs_1[i] <- compute_MISE(dpois, fs_hat, samples, 50, 8)
  i <- i + 1
}
MISEs_1
```

计算MISE，CV方法
```{r eval=FALSE, include=FALSE}
#samples <- generate_samples(rpois, 50, 50, 8)

n_s <- c(25, 50, 100, 200, 400, 800)
MISEs <- numeric(length(n_s))
i <- 1
set.seed(2333)
for (n in n_s) {
  samples <- generate_samples(rpois, n, 50, 8)
  fs_hat <- compute_fs_hat(samples, "bino", FALSE)
  MISEs[i] <- compute_MISE(dpois, fs_hat, samples, 50, 8)
  i <- i + 1 
}
MISEs
```

表格3
```{r eval=FALSE, include=FALSE}
library(knitr)
error_difference <- (MISEs_1 - MISEs) / MISEs_1 * 100 * (-1)
MISE <- data.frame(n = n_s, bayes = MISEs_1, CV = MISEs, error = error_difference)
MISE_table <- kable(MISE, format = "latex")
MISE_table
```

compute_MISECV函数
```{r eval=FALSE, include=FALSE}
compute_MISECV <- function(n) {
  set.seed(2333)
  samples <- generate_samples(rpois, n, 1, 8)
  fs_hat <- compute_fs_hat(samples, "bino", FALSE)
  compute_MISE(dpois, fs_hat, samples, 1, 8)
}

```

compute_MISE_bayes函数
```{r eval=FALSE, include=FALSE}
compute_MISE_bayes <- function(n) {
  set.seed(2333)
  samples <- generate_samples(rpois, n, 1, 8)
  fs_hat <- compute_fs_hat(samples, bino, TRUE, type = "func")
  compute_MISE(dpois, fs_hat, samples, 1, 8)
}
```

下面两个代码块可以得到表格4

使用microbenchmark计算贝叶斯方法的时间
```{r eval=FALSE, include=FALSE}
n_s <- c(25, 50, 100, 200, 400, 800)

exec_time_bayes <- list(
  microbenchmark("n=25" = compute_MISE_bayes(25)),
  microbenchmark("n=50" = compute_MISE_bayes(50)),
  microbenchmark("n=100" = compute_MISE_bayes(100)),
  microbenchmark("n=200" = compute_MISE_bayes(200)),
  microbenchmark("n=400" = compute_MISE_bayes(400)),
  microbenchmark("n=800" = compute_MISE_bayes(800))
)

```

使用microbenchmark计算CV方法的时间
```{r eval=FALSE, include=FALSE}
exec_time_CV <- list(
  microbenchmark("n=25" = compute_MISECV(25)),
  microbenchmark("n=50" = compute_MISECV(50)),
  microbenchmark("n=100" = compute_MISECV(100)),
  microbenchmark("n=200" = compute_MISECV(200), times = 10),
  microbenchmark("n=400" = compute_MISECV(400), times = 5),
  microbenchmark("n=800" = compute_MISECV(800), times = 3)
)
```














